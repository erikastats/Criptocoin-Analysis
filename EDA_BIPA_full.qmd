---
title: "EDA BIPA"
author: "Érika Borelli"
format: html
editor: visual
---

## Objetivo

Este documento tem como objetivo fazer a análise exploratória dos dados que compõem o Desafio técnico para a vaga de Data Analytics na BIPA.

## Importação dos dados

Criando banco de dados

```{r}
#| include: false
library(gt)
library(ggplot2)
library(hrbrthemes)
library(tidyr)
library(scales)
```

```{r}
#| include: false
source("ccreating_db.R")
```

Funções para importação dos dados

```{r}
import_data <- function(data_name){
  query = paste0("SELECT * FROM ", data_name)
  df = query_data(query)
  colunas_tempo <- grep("_at$", names(df), value = TRUE)
  
  for (col in colunas_tempo) {
    # Aplica conversão apenas se os valores forem numéricos inteiros grandes (ex: 1630378347)
    if (is.numeric(df[[col]]) && all(df[[col]] > 1000000000, na.rm = TRUE)) {
      df[[col]] <- as.POSIXct(df[[col]], origin = "1970-01-01", tz = "UTC")
    }
  }
  
  df
}
```

Importando as tabelas para uma visualização mais fácil

```{r}
users = import_data("users")

assets = import_data("assets")

card_holder = import_data("card_holder")

card_purchases = import_data("card_purchases")

internal_transfers = import_data("internal_transfers")

orders = import_data("orders")

pix_transactions = import_data("pix_transactions")

quotes = import_data("quotes")
```

## Exploração dos dados

```{r}
usuario_atividade = query_data("select 
                                count(id) as quantidade_users,
                                active
                                from users
                                group by active")
usuario_atividade |> 
  gt() |>
  tab_header(
    title = "Distribuição de usuários ativos"
  )
```

Aqui já vemos que temos no total 10 usuários, mas 2 deles estão classificados como inativos. Porém, qual seria a definição de um usuário inativo?

-   Alguém que fez a conta na BIPA e nunca interagiu com nada?

-   Um usuário que cancelou a conta e não vai usar mais?

Se fosse questão de cancelamento, seria interessante ter a data do cancelamento, mas como não tem, me faz pensar qeu é a primeira opção, ou algo diferente. Vou tentar descobrir analisando os dados.

```{r}
pix_direcao = query_data( " select
                           count(id) total_pix,
                           sum(amount_brl) total_amount,
                           user_id,
                           direction
                           from pix_transactions
                           group by user_id, direction")
pix_direcao |> 
  gt() |>
  tab_header(
    title = "Quantidade de transções pix por usuário"
  )
```

Vemos que apesar do usuário id = 2 estar como inativo, ele utilizou a conta para fazer pix. Não há pix realizado para os usuários 1, 3, 5, 7 e 10.

```{r}
utili_cartao = query_data("with compras_cartao as (
select
user_id as usuario_do_cartao,
card_id,
count(id) as total_purchase
from card_purchases
group by user_id, card_id
)

select cc.*,
ch.user_id as dono_cartao
from compras_cartao as cc
left join card_holder ch on cc.card_id = ch.card_id
order by cc.card_id " )
utili_cartao |> 
  gt() |>
  tab_header(
    title = "Usuários que utilizaram o cartão da BIPA"
  )
```

Aqui os dados já apresentam resultados um pouco estranhos. Foi identificado que todos os usuários que realizaram alguma compra utilizaram cartões de outo usuário (informação cruzada entre as tabelas `card_holder` e `card_purchases` ). Esse comportamento pode refletir uam simulação de cartões compartilhados ou uma inconsistência nos dados fictícios fornecidos. Para efeito das métricas desenvolvidas, considerou-se que a atividade de um usuário independe da titularidade do cartão utilizado.

```{r}
proposta_ativos = query_data("select
                              count(id) total_proposta, 
                              user_id, 
                              side
                              from quotes
                              group by user_id, side
                              ")
proposta_ativos |> 
  gt() |>
  tab_header(
    title = "Proposta de compra e venda de ativos"
  )
```

Aqui é preciso olhar com mais cuidado no que está acontecendo. Vamos filtrar pelas propostas concluídas e adicionar o usuário em ordens.

```{r}
proposta_concluidas = query_data("with quotes_not_null as (select
                              id, 
                              user_id, 
                              side
                              from quotes
                              where accepted_at is not null)
                              
                              select qnn.*,
                              o.user_id as user_order
                              from quotes_not_null qnn
                              left join orders o on qnn.id = o.quote_id
                              ")
proposta_concluidas |> 
  gt() |>
  tab_header(
    title = "Proposta de compra e venda de ativos concluídos"
  )
```

Aqui vemos que ao juntar a tabela `quotes` com a tabela `orders` , os usuários de um certo quote_id não são os mesmos para ambas as tabelas, o que poderia indicar que provavelmente o usuário da tabela `quotes` abriu a ordem ali para comprar e vender algo, e já da tabela `orders` seria quem aceitou a transação. Algo do tipo:

```         
-   Um usuário cria a oferta (`quotes`)

-   Outro usuário aceita a oferta (`orders`)
```

Porém, essa lógica falha ao verificar que o quote_id de número 13 tem o mesmo usuário em ambas as tabelas. O que pode significar o mesmo user_id em `quotes` e `orders`:

1.  Autoexecução da própria oferta (self_trade):
2.  bug no sistema ou nos dados simulados
3.  Ordem pendente de execução
4.  Sistema interno de roteamento

A tabela `quotes` parece representar ofertas de compra e venda feitas por usuários, com os seguintes campos temporais:

-   `created_at`: data de criação da oferta
-   `expires_at`: data-limite sugerida para expiração
-   `accepted_at`: data em que a oferta foi aceita
-   `expired_at`: data em que a oferta foi marcada como expirada pelo sistema

Ao inspecionar os dados, observei que:

-   Nenhuma linha possui `accepted_at` **e** `expired_at` preenchidos simultaneamente.
-   Existem ofertas aceitas **após** o `expires_at`, o que indica que o sistema permite execução mesmo após o prazo-limite.
-   Em alguns casos, `created_at` vem **depois** do `expired_at`, o que pode indicar inconsistência nos dados ou simulações.

Esses padrões serão considerados na análise de comportamento e métricas dos usuários.

```{r}
trans_inter = query_data(" with int_trans_send as (
                          select
                          sender_user_id as user_id,
                          count(id) total_transf,
                          sum(amount_brl) as total_amount
                          from internal_transfers
                          group by sender_user_id
                          ),
                          
                          int_trans_recei as (
                          select
                          receiver_user_id as user_id,
                          count(id) total_transf,
                          sum(amount_brl) as total_amount
                          from internal_transfers
                          group by receiver_user_id
                          )
                          
                          SELECT *,
                          'sender' as tipo_trans
                          FROM int_trans_send 
                          union all 
                          SELECT *, 
                          'receiver' as tipo_trans
                          FROM int_trans_recei
                          order by user_id
                          ")
trans_inter |> 
  gt() |>
  tab_header(
    title = "Transferência interna por usuário"
  )
```

Aqui podemos observar que um dos usuários tidos como inativos (user_id = 10) recebeu uma transferência interna. Outro ponto a se chamar atenção é que na transferência interna id= 2, o mesmo usuário manda pra si mesmo. O que pode ocorrer caso seja transferências entre carteiras interna do mesmo usuário, conversão entre ativos, depósito de bonificação ou cashback automatizado, ou até mesmo erro dos dados gerados.

```{r}
query = "
with dt_union as (
select
u.id,
u.created_at,
q.created_at as quote_created_at,
ch.created_at as card_created_at,
ch.updated_at as card_updated_at,
pix.created_at as pix_created_at,
o.created_at as order_created_at,
cp.created_at as card_pu_created_at,
cp.updated_at as card_pu_updated_at
from users u
left join quotes q on u.id = q.user_id
left join card_holder ch on u.id = ch.user_id
left join pix_transactions pix on u.id = pix.user_id
left join orders o on u.id = o.user_id
left join card_purchases cp on u.id = cp.user_id
where u.active = 0
),
dt_union_pivot as (

SELECT id, 'quote_created_at' AS nome_coluna, quote_created_at AS valor
FROM dt_union

UNION ALL

SELECT id, 'card_created_at', card_created_at
FROM dt_union

UNION ALL

SELECT id, 'card_updated_at', card_updated_at
FROM dt_union

UNION ALL

SELECT id, 'pix_created_at', pix_created_at
FROM dt_union

UNION ALL

SELECT id, 'order_created_at', order_created_at
FROM dt_union

UNION ALL

SELECT id, 'card_pu_created_at', card_pu_created_at
FROM dt_union

UNION ALL

SELECT id,  'card_pu_updated_at', card_pu_updated_at
FROM dt_union),
ordenado as(

select distinct id,  nome_coluna, 
datetime(valor, 'unixepoch') as date,
row_number() over (partition by id order by datetime(valor, 'unixepoch') DESC) as rn
from dt_union_pivot
where valor is not null)

select o.*,
u.active
from ordenado o
left join users u on o.id = u.id
where o.rn = 1
"

query_data(query) |> 
  gt() |>
  tab_header(
    title = "Data da última atividade"
  )
```

Por enquanto não achei nenhum padrão para inatividade. Então provavelmente seriam clientes que cancelaram a conta.

## Visualizações

Quando cada usuário criou uma conta

```{r}
query = "
select id, datetime(created_at, 'unixepoch') as created_at, active
from users"

usuario_date <- query_data(query)

ggplot(usuario_date,
       aes(x  = created_at, y = id, shape = as.character(active) )) +
  geom_point(size = 6) +
  ggtitle("Data de criação do usuário") +
  theme_ipsum()
  
```

## Taxa de crescimento

Para esta análise foi escolhido e utilizado o Growth rate como métrica para representar o crescimento dos produtos internos.

$$
\text{Taxa de Crescimento} = \frac{V_{\text{atual}} - V_{\text{anterior}}}{V_{\text{anterior}}} \times 100
$$

Taxa de crescimento por mês que teve novas entradas

```{r}
query = "WITH month_user AS (
  SELECT 
    COUNT(DISTINCT id) AS new_users_count,
    strftime('%Y-%m', datetime(created_at, 'unixepoch')) AS month
  FROM users
  GROUP BY month
),

with_cumulative AS (
  SELECT 
    month,
    new_users_count,
    SUM(new_users_count) OVER (ORDER BY month) AS cumulative_users
  FROM month_user
),

with_growth AS (
  SELECT
    month,
    new_users_count,
    cumulative_users,
    LAG(cumulative_users) OVER (ORDER BY month) AS prev_cumulative
  FROM with_cumulative
)

SELECT 
  month,
  new_users_count,
  cumulative_users,
  prev_cumulative,
  CASE 
    WHEN prev_cumulative IS NULL OR prev_cumulative = 0 THEN NULL
    ELSE ROUND((cumulative_users - prev_cumulative) * 1.0 / prev_cumulative * 100, 2)
  END AS growth_rate_percent
FROM with_growth
ORDER BY month;

"

cum_month <- query_data(query)


```

```{r}
cum_month |> 
  mutate(growth_rate_percent = growth_rate_percent |> 
           replace_na(0))  |> 
  ggplot(aes(x = month, y = growth_rate_percent, group = 1)) +
    geom_line() +
  geom_point()
```

```{r}
scaling_factor <- max(cum_month$new_users_count, na.rm = TRUE) / 
                  max(cum_month$growth_rate_percent, na.rm = TRUE)

ggplot(cum_month, aes(x = month)) +
  geom_col(aes(y = new_users_count), fill = "skyblue", alpha = 0.6) +
  geom_line(aes(y = growth_rate_percent * scaling_factor), color = "darkred", linewidth = 1.2, group = 1) +
  scale_y_continuous(
    name = "Novos usuários (absoluto)",
    sec.axis = sec_axis(~./scaling_factor, name = "Taxa de Crescimento (%)")
  ) +
  labs(x = "Mês", title = "Crescimento mensal de usuários BIPA") +
  theme_minimal() +
  theme(
    axis.title.y.right = element_text(color = "darkred"),
    axis.text.y.right = element_text(color = "darkred")
  )
```

```{r}
growth_metric_plot <-  function(df, xtitle, plottitle, xcolname){
  
  id_col <- which(names(df) == xcolname)
  names(df)[id_col] = 'date'
  scaling_factor <- max(df$new_users_count, na.rm = TRUE) / 
                  max(df$growth_rate_percent, na.rm = TRUE)

ggplot(df, aes(x = date)) +
  geom_col(  aes(y = new_users_count), fill = "#4e66e7", alpha = 0.6) +
  geom_line( aes(y = growth_rate_percent * scaling_factor),
              color = "darkred", linewidth = 1.2, group = 1) +
  geom_text( aes(
      y = growth_rate_percent * scaling_factor,
      label = paste0( round(growth_rate_percent, 1), "%"),
      ),
      vjust = -0.5,
      color = 'black',
      size = 3, 
      fontface = "plain",
      show.legend = FALSE) +
  scale_y_continuous(
      name = "Novos usuários (absoluto)",
      sec.axis = sec_axis(~./scaling_factor, name = "Taxa de Crescimento (%)")
  ) +
  labs(x = xtitle, title = plottitle) +
  theme_minimal() +
  theme(
      axis.title.y.right = element_text(color = "darkred"),
      axis.text.y.right = element_text(color = "darkred")
  )
}
```

```{r}
growth_metric_plot(cum_month, "Mês","Crescimento mensal de usuários BIPA", 'month' )
```

Como a base de dados fornecida é uma **amostra** e não contém um histórico contínuo ou completo dos usuários ao longo do tempo, optei por **considerar apenas os meses com registros efetivos de novos usuários** para o cálculo da taxa de crescimento.\

Essa abordagem evita distorções nos resultados e foca nos momentos em que houve de fato atividade relevante na plataforma.

### Isso resolve 2 coisas ao mesmo tempo:

1.  **Evita artificializar o tempo** com meses vazios (que poderiam enviesar a leitura).

2.  **Simplifica a análise**, já que não é necessário gerar uma sequência mensal completa.

```         
`cumulative_users`: total de usuários acumulados até o mês atual

`prev_cumulative`: total de usuários acumulados até o mês anterior (usando `LAG()`)
```

Outra informação importante é retirar os usuários inativos. COmo não há explicitamente quando os usuários ficaram inativos, levarei em consideração que ele ficou inativo após a data da sua última ação. E o que seria considerado "ação" neste caso:

-   Criar um cartão

-   Fazer uma compra

-   Fazer uma transferência interna

-   Criar um quote ou order

-   Fazer um PIX

Taxa de crescimento por ano

```{r}
query = "WITH year_user AS (
  SELECT 
    COUNT(DISTINCT id) AS new_users_count,
    strftime('%Y', datetime(created_at, 'unixepoch')) AS year
  FROM users
  GROUP BY year
),

with_cumulative AS (
  SELECT 
    year,
    new_users_count,
    SUM(new_users_count) OVER (ORDER BY year) AS cumulative_users
  FROM year_user
),

with_growth AS (
  SELECT
    year,
    new_users_count,
    cumulative_users,
    LAG(cumulative_users) OVER (ORDER BY year) AS prev_cumulative
  FROM with_cumulative
)

SELECT 
  year,
  new_users_count,
  cumulative_users,
  prev_cumulative,
  CASE 
    WHEN prev_cumulative IS NULL OR prev_cumulative = 0 THEN NULL
    ELSE ROUND((cumulative_users - prev_cumulative) * 1.0 / prev_cumulative * 100, 2)
  END AS growth_rate_percent
FROM with_growth
ORDER BY year;

"

cum_year <- query_data(query)
```

```{r}
growth_metric_plot(cum_year, "Ano","Crescimento anual de usuários BIPA", 'year' )
```

## Cartões

### ✅ **Opção 1: Crescimento por número de usuários novos no serviço**

**Mede:** quantos *novos usuários únicos* passaram a utilizar o serviço em cada período.

**Interpretação:**

> Reflete a *adoção do serviço* por usuários novos ou recorrentes que antes nunca haviam utilizado aquele produto/serviço específico.

**💡 Quando usar:**

-   Quando o foco é entender a expansão da base de usuários daquele serviço.

    Bom para avaliar campanhas de cross-sell ou onboarding.

### ✅ **Opção 2: Crescimento pelo número total de serviços utilizados no período**

**Mede:** o total de utilizações do serviço (independente do usuário já ter usado antes).

**Interpretação:**

> Mede a *intensidade de uso* — pode crescer mesmo que não haja novos usuários, apenas mais uso pelos mesmos.

**💡 Quando usar:**

-   o o foco é entender o crescimento do volume operacional.

    Útil para mensurar impacto de melhorias de UX, mudanças de tarifa, sazonalidade etc.

### ✅ **Opção 3: Usar as duas abordagens**

Você não está soando exagerada se usar as duas — elas respondem perguntas diferentes:

| Pergunta | Métrica mais adequada |
|------------------------------------|------------------------------------|
| Estamos conquistando mais usuários para esse serviço? | **Usuários novos no serviço** |
| O serviço está sendo mais utilizado (independente de quem usa)? | **Quantidade total de uso** |

### ✨ Recomendação prática

1.  

2.  **Mostre as duas métricas (em gráficos separados ou um painel):**\
    → Isso mostra sua maturidade como analista, pois você está abordando o crescimento de forma multifacetada.

3.  

4.  **Na apresentação, deixe claro que você pensou nas duas óticas:**\
    → Ex: “Como o crescimento pode se manifestar tanto na adesão de novos usuários quanto no aumento do uso pelos já existentes, analisei ambas as dimensões.”

5.  

6.  **Escolha uma principal para justificar (se pedirem):**\
    → Pode ser a de novos usuários se o foco estiver em **expansão da base**, ou total de uso se o foco estiver em **crescimento do volume transacional**.

### ✅ **Objetivo final**

Criar uma visão macro da **adoção dos serviços da BIPA ao longo do tempo**, separando por:

-   

-   Produtos (ex: cartão, cotações)

-   

-   Transações (ex: Pix, compras, pedidos)

-   

### ✅ **Etapas sugeridas**

1.  

2.  **Criar uma tabela unificada com o 1º uso de cada serviço por `user_id`**\
    Exemplo:

    ```         
    sql
    ```

    CopiarEditar

    `SELECT user_id, 'Cartão' AS servico, MIN(created_at) AS first_use FROM card_holder GROUP BY user_id`

3.  

4.  **Repetir isso para cada serviço**:

    -   

    -   Quotes → 'Cotação'

    -   

    -   Pix_transactions → 'Pix'

    -   

    -   Card_purchases → 'Compra com cartão'

    -   

    -   Orders → 'Pedido'

    -   

5.  

6.  **Fazer um `UNION ALL` entre todos os serviços**

7.  

8.  **Transformar a data em mês (`strftime('%Y-%m', ...)`)**

9.  

10. **Contar número de usuários únicos por serviço e por mês**

11. 

12. **Criar colunas auxiliares: acumulado e taxa de crescimento por serviço**

13. 

14. **Visualizar num gráfico com `facet_wrap(~servico)` ou cores por categoria**

15. 

### 💡 Exemplo de estrutura unificada (passo 3 e 4)

```         
sql
```

CopiarEditar

`WITH unificado AS (   SELECT user_id, 'Cartão' AS servico, MIN(datetime(created_at, 'unixepoch')) AS dt   FROM card_holder GROUP BY user_id    UNION ALL    SELECT user_id, 'Cotação', MIN(datetime(created_at, 'unixepoch'))   FROM quotes GROUP BY user_id    UNION ALL    SELECT user_id, 'Pix', MIN(datetime(created_at, 'unixepoch'))   FROM pix_transactions GROUP BY user_id    UNION ALL    SELECT user_id, 'Compra com cartão', MIN(datetime(created_at, 'unixepoch'))   FROM card_purchases GROUP BY user_id    UNION ALL    SELECT user_id, 'Pedido', MIN(datetime(created_at, 'unixepoch'))   FROM orders GROUP BY user_id ), servico_por_mes AS (   SELECT     servico,     strftime('%Y-%m', dt) AS month,     COUNT(DISTINCT user_id) AS novos_usuarios   FROM unificado   GROUP BY servico, month )`

### 📊 Visualização sugerida

Depois de calcular a taxa de crescimento em cima de `servico_por_mes`, você pode usar no R:

```         
r
```

CopiarEditar

`ggplot(df, aes(x = month, y = growth_rate, color = categoria)) +   geom_line() +   facet_wrap(~ servico) +   theme_minimal()`

### ✅ Vantagens dessa abordagem final:

-   Resume **a adoção de todos os serviços** num único panorama;

-   Mostra quais serviços puxam o crescimento da empresa;

-   Ajuda a justificar decisões estratégicas como: **em que produtos investir mais**.

### Pontos fortes e fracos da métrica

-   **Ponto forte:** conecta diretamente ao comportamento do usuário e ao engajamento com o ecossistema da Bipa.

-   **Ponto fraco:** se não estiver muito bem definido, pode ser interpretado como “menos estratégico” que métricas financeiras como GTV ou receita.

### Growth Rate de Engajamento Multi-Produto

#### Definição

Taxa de crescimento no número de usuários ativos que utilizam dois ou mais produtos internos da BIPA (por exemplo: cartão + PIX, PIX + compra de ativos, etc.) em um determinado período.

Fórmula

$$
\text{Growth Rate} = \frac{\text{Usuários Multi-Produto}_{\text{Período Atual}} - \text{Usuários Multi-produto}_{\text{Período Anterior}}}{\text{Usuários Multi-produto}_{\text{Período Anterior}}}
$$

Onde:

-   Usuários Multi-Produto = número de usuários distintios que realizaram pelo menos 1 operação em $\geq 2$ tipos diferentes de produtos no período.

#### Por que é a métrica principal

1.  Reflete retenção e profundidade de uso - usuários que usam mais de um produto tendem a ter maior lifetime value
2.  Alinha com a estratégia de expansão - se a Bipa quer aumentar uso dos produtos internos, esse índice mostra se estamos conseguindo "cruzar" clientes entre serviços.
3.  Diretamente acionável - pode inspirar campanhas de incentivo ao uso combinado
4.  Completa métricas financeiras - pode crescer mesmo quando receita oscila, indicando base engajada pronta para monetizar.

#### Visualização sugerida

-   Gráfico de linah com evolução mensal da taxa de crescimento dos usuários multi-produto

-   Gráfico de barras mostrando quais combinações de produtos são masi comuns (cartão + Pix, Pix + ativos, etc)

## **Resultados**

### **1. Métrica Principal – Growth Rate Geral**

-   

-   

    **Definição rápida** (1 frase, já apresentada antes).

-   

-   

    **Tabela ou gráfico** mostrando a taxa de crescimento mensal e/ou anual da base engajada.

-   

-   

    **1–2 frases de interpretação**: “O crescimento médio mensal foi de X%, com destaque para os meses Y e Z, onde houve picos devido a …”.

-   

### **2. Segmentação por Produto e Operação**

-   

-   

    Breve introdução: “Para entender a contribuição de cada produto para a métrica geral, a Growth Rate foi calculada individualmente por tipo de serviço”.

-   

-   

    **Gráfico comparativo** (ex.: linhas ou barras lado a lado) com a taxa de crescimento mensal de cada produto.

-   

-   

    **Insights-chave** (bullet points, no máximo 3):

    -   

    -   

        “PIX apresentou crescimento consistente, sendo responsável por X% do crescimento total em Mês Y”.

    -   

    -   

        “Cartão teve queda em Mês Z, impactando negativamente o crescimento geral”.

    -   

    -   

        “Orders cresceram após a campanha ABC”.

    -   

-   

### **3. Análise Individual de Engajamento por Serviço**

-   

-   

    Introdução curta: “Além da taxa de crescimento, avaliou-se o engajamento de cada produto de forma isolada para identificar padrões específicos de uso”.

-   

-   

    **Mini-seção por produto** (máximo 3 linhas cada + 1 gráfico pequeno):

    -   

    -   

        *PIX*: evolução de usuários ativos e transações.

    -   

    -   

        *Cartão*: evolução de criação de cartões e compras realizadas.

    -   

    -   

        *Orders/Quotes*: evolução de usuários e volume de ativos negociados.

    -   

    -   

        *Transferências internas*: frequência e base engajada.

    -   

-   

-   

    **Resumo geral** (1 parágrafo): “Os produtos que mais contribuíram para o engajamento total foram…”.

-   

### **4. Contribuição Relativa para o Crescimento Total**

-   

-   

    **Gráfico de contribuição** (ex.: gráfico de área empilhada ou waterfall mostrando % do crescimento atribuída a cada produto).

-   

-   

    Interpretação final (1 parágrafo) ligando com o objetivo do desafio:

    -   

    -   

        “Essa análise mostra que o crescimento da base engajada é puxado principalmente por…, o que indica oportunidades de…”.

    -   

-   

💡 **Estratégia**:

-   

-   

    O avaliador bate o olho e vê que **você tem uma métrica principal clara**.

-   

-   

    As análises adicionais não parecem “outras métricas”, mas sim **formas diferentes de dissecar a mesma métrica**.

-   

-   

    Você aproveita todo o trabalho que já fez ontem, mas mantém a narrativa curta e direta.
